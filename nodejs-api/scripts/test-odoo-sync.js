#!/usr/bin/env node
/**
 * Test Odoo Integration Script
 *
 * This script randomly picks a product from the database and attempts to sync it to Odoo.
 * Use this to verify the integration is working properly before doing a full sync.
 *
 * Usage:
 *   node scripts/test-odoo-sync.js
 *   node scripts/test-odoo-sync.js --product-id <id>  # Test specific product
 *   node scripts/test-odoo-sync.js --sku <sku>        # Test specific SKU
 *   node scripts/test-odoo-sync.js --dry-run          # Show what would be synced without calling Odoo
 *   node scripts/test-odoo-sync.js --export           # Export detailed API logs to a file for sharing
 */

require("dotenv").config();
const { PrismaClient } = require("@prisma/client");
const fs = require("fs");
const path = require("path");

const prisma = new PrismaClient();

// Parse command line arguments
const args = process.argv.slice(2);
const getArg = (flag) => {
  const index = args.indexOf(flag);
  return index !== -1 ? args[index + 1] : null;
};
const hasFlag = (flag) => args.includes(flag);

const specificProductId = getArg("--product-id");
const specificSku = getArg("--sku");
const isDryRun = hasFlag("--dry-run");
const isVerbose = hasFlag("--verbose") || hasFlag("-v");
const shouldExport = hasFlag("--export");

// Colors for console output
const colors = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  cyan: "\x1b[36m",
};

function log(message, color = "reset") {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSection(title) {
  console.log("");
  log(`${"=".repeat(60)}`, "cyan");
  log(`  ${title}`, "bright");
  log(`${"=".repeat(60)}`, "cyan");
}

// Store API call details for export
const apiCallLog = {
  timestamp: new Date().toISOString(),
  environment: process.env.NODE_ENV || "development",
  calls: [],
};

function logApiCall(details) {
  apiCallLog.calls.push({
    ...details,
    timestamp: new Date().toISOString(),
  });
}

function exportApiLog(
  config,
  product,
  variantsInChannel,
  odooPayload,
  results = [],
) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  const filename = `odoo-api-test-${timestamp}.md`;
  const filepath = path.join(__dirname, "..", filename);

  let md = `# Odoo API Integration Test Report

**Generated:** ${new Date().toISOString()}  
**Environment:** ${process.env.NODE_ENV || "development"}

---

## Configuration

| Setting | Value |
|---------|-------|
| Base URL | ${config.baseUrl || "Not set"} |
| API Key | ${config.apiKey ? config.apiKey.substring(0, 8) + "..." : "Not set"} |
| Sales Channel | ${config.salesChannelId || "None"} |
| Integration Enabled | ${config.isEnabled ? "Yes" : "No"} |

---

## Test Product

| Field | Value |
|-------|-------|
| Product Name | ${product.name} |
| Product ID | ${product.id} |
| Total Variants | ${product.variants.length} |
| Variants in Channel | ${variantsInChannel.length} |

### Variants Being Synced

| SKU | Name | Available Stock | Price |
|-----|------|-----------------|-------|
${variantsInChannel.map((v) => `| ${v.sku} | ${v.name} | ${v.availableStock} | $${v.price.toFixed(2)} |`).join("\n")}

---

## API Calls

`;

  // Add each API call
  for (const call of apiCallLog.calls) {
    md += `### ${call.operation}

**Method:** \`POST\`  
**URL:** \`${call.fullUrl}\`

#### Request Headers

\`\`\`
Content-Type: application/json
api-key: ${call.requestHeaders?.["api-key"] || "<API_KEY>"}
\`\`\`

#### Request Body

\`\`\`json
${JSON.stringify(call.requestBody, null, 2)}
\`\`\`

#### Response

`;

    if (call.skipped && call.note) {
      md += `*${call.note}*\n\n`;
    } else if (call.success === true) {
      md += `**Status:** âœ… SUCCESS (${call.duration}ms)  
**HTTP Status:** ${call.statusCode || "N/A"}

\`\`\`json
${JSON.stringify(call.response, null, 2)}
\`\`\`

`;
    } else if (call.success === false) {
      md += `**Status:** âŒ FAILED  
**Error:** ${call.error || "Unknown"}

\`\`\`json
${JSON.stringify(call.response, null, 2)}
\`\`\`

`;
    } else {
      md += `*No response - dry run mode*\n\n`;
    }

    md += `---

`;
  }

  // Add summary
  md += `## Summary

| Metric | Value |
|--------|-------|
| Total API Calls | ${apiCallLog.calls.length} |
| Successful | ${apiCallLog.calls.filter((c) => c.success === true).length} |
| Failed | ${apiCallLog.calls.filter((c) => c.success === false).length} |
| Skipped/Dry Run | ${apiCallLog.calls.filter((c) => c.skipped).length} |

---

*Report generated by test-odoo-sync.js*
`;

  fs.writeFileSync(filepath, md);
  return filepath;
}

async function main() {
  logSection("Odoo Integration Test Script");

  if (isDryRun) {
    log("ğŸ” DRY RUN MODE - No actual API calls will be made", "yellow");
  }

  try {
    // Step 1: Check if integration is enabled
    logSection("Step 1: Checking Integration Status");

    const config = await prisma.odooIntegrationConfig.findFirst();

    if (!config) {
      log("âŒ No Odoo integration configuration found!", "red");
      log(
        "   Please configure Odoo integration in Settings > Sales Channels",
        "yellow",
      );
      process.exit(1);
    }

    log(`ğŸ“‹ Configuration found:`, "green");
    log(`   - Enabled: ${config.isEnabled ? "Yes" : "No"}`);
    log(`   - Base URL: ${config.baseUrl || "Not set"}`);
    log(`   - Sales Channel ID: ${config.salesChannelId || "None linked"}`);
    log(`   - Last Sync: ${config.lastSyncAt || "Never"}`);

    if (!config.isEnabled) {
      log(
        "âš ï¸  Integration is disabled - running in TEST MODE anyway",
        "yellow",
      );
    }

    // Step 2: Get sales channel info
    let salesChannel = null;
    if (config.salesChannelId) {
      salesChannel = await prisma.salesChannel.findUnique({
        where: { id: config.salesChannelId },
        select: { id: true, companyName: true },
      });
      if (salesChannel) {
        log(`   - Linked Channel: ${salesChannel.companyName}`, "green");
      }
    }

    // Step 3: Select a product to test
    logSection("Step 2: Selecting Product");

    let product;

    if (specificProductId) {
      log(`Looking for specific product ID: ${specificProductId}`, "blue");
      product = await prisma.product.findUnique({
        where: { id: specificProductId },
        include: {
          variants: {
            where: { isActive: true },
            include: {
              inventory: {
                where: { location: { isActive: true } },
                include: { location: true },
              },
            },
          },
        },
      });
    } else if (specificSku) {
      log(`Looking for variant with SKU: ${specificSku}`, "blue");
      const variant = await prisma.productVariant.findFirst({
        where: { sku: specificSku },
        select: { productId: true },
      });
      if (variant) {
        product = await prisma.product.findUnique({
          where: { id: variant.productId },
          include: {
            variants: {
              where: { isActive: true },
              include: {
                inventory: {
                  where: { location: { isActive: true } },
                  include: { location: true },
                },
              },
            },
          },
        });
      }
    } else {
      // Random product selection - ONLY products with multiple variants
      log("Selecting random product (multi-variant products only)...", "blue");

      let productIds = [];

      // Get active products with MORE THAN 1 variant only
      const activeProducts = await prisma.product.findMany({
        where: {
          status: "ACTIVE",
          variants: { some: { isActive: true } },
        },
        select: {
          id: true,
          _count: {
            select: { variants: { where: { isActive: true } } },
          },
        },
        take: 200,
      });

      // Only include products with more than 1 variant
      const multiVariantProducts = activeProducts.filter(
        (p) => p._count.variants > 1,
      );

      if (multiVariantProducts.length === 0) {
        log("âŒ No products with multiple variants found in database!", "red");
        log(
          "   This test requires products with more than 1 variant.",
          "yellow",
        );
        process.exit(1);
      }

      // If sales channel is configured, filter to only products in that channel
      if (config.salesChannelId) {
        const channelPrices = await prisma.salesChannelPrice.findMany({
          where: { salesChannelId: config.salesChannelId },
          select: { variant: { select: { productId: true } } },
        });
        const channelProductIds = new Set(
          channelPrices.map((p) => p.variant.productId),
        );

        const multiVariantInChannel = multiVariantProducts.filter((p) =>
          channelProductIds.has(p.id),
        );

        if (multiVariantInChannel.length > 0) {
          productIds = multiVariantInChannel.map((p) => p.id);
          log(
            `   Found ${productIds.length} multi-variant products in linked sales channel`,
            "cyan",
          );
        } else {
          // Use all multi-variant products if none in channel
          productIds = multiVariantProducts.map((p) => p.id);
          log(
            `   No multi-variant products in sales channel, using ${productIds.length} from database`,
            "yellow",
          );
        }
      } else {
        productIds = multiVariantProducts.map((p) => p.id);
        log(
          `   Found ${productIds.length} products with multiple variants`,
          "cyan",
        );
      }

      if (productIds.length === 0) {
        log("âŒ No active products found in database!", "red");
        process.exit(1);
      }

      // Pick random product
      const randomIndex = Math.floor(Math.random() * productIds.length);
      const randomProductId = productIds[randomIndex];

      product = await prisma.product.findUnique({
        where: { id: randomProductId },
        include: {
          variants: {
            where: { isActive: true },
            include: {
              inventory: {
                where: { location: { isActive: true } },
                include: { location: true },
              },
            },
          },
        },
      });
    }

    if (!product) {
      log("âŒ Product not found!", "red");
      process.exit(1);
    }

    log(`âœ… Selected Product: ${product.name}`, "green");
    log(`   - ID: ${product.id}`);
    log(`   - Status: ${product.status}`);
    log(`   - Variants: ${product.variants.length}`);

    // Step 4: Show variant details and what will be synced
    logSection("Step 3: Variant Details");

    const variantSummary = [];

    for (const variant of product.variants) {
      // Calculate available stock
      let totalStock = 0;
      let reservedStock = 0;
      for (const inv of variant.inventory) {
        totalStock += inv.quantity || 0;
        reservedStock += inv.reservedQty || 0;
      }
      const availableStock = Math.max(0, totalStock - reservedStock);

      // Get price from sales channel
      let price = parseFloat(variant.regularPrice || 0);
      let priceSource = "variant regular price";

      if (config.salesChannelId) {
        const channelPrice = await prisma.salesChannelPrice.findUnique({
          where: {
            salesChannelId_variantId: {
              salesChannelId: config.salesChannelId,
              variantId: variant.id,
            },
          },
        });
        if (channelPrice) {
          price = parseFloat(channelPrice.price);
          priceSource = `sales channel (${salesChannel?.name || config.salesChannelId})`;
        } else {
          priceSource = "NOT IN CHANNEL - will be skipped";
        }
      }

      // Get attributes (strength from variant name)
      const variantOptions = await prisma.variantOption.findMany({
        where: { variantId: variant.id },
      });

      let strength = variant.name; // Default to variant name
      const strengthOption = variantOptions.find(
        (vo) => vo.name?.toLowerCase() === "strength",
      );
      if (strengthOption) {
        strength = strengthOption.value;
      }

      variantSummary.push({
        sku: variant.sku,
        name: variant.name,
        strength,
        totalStock,
        reservedStock,
        availableStock,
        price,
        priceSource,
        inChannel: priceSource !== "NOT IN CHANNEL - will be skipped",
      });

      log(`\nğŸ“¦ Variant: ${variant.name}`, "bright");
      log(`   SKU: ${variant.sku}`);
      log(`   Strength: ${strength}`);
      log(
        `   Stock: ${availableStock} available (${totalStock} total - ${reservedStock} reserved)`,
      );
      log(`   Price: $${price.toFixed(2)} (${priceSource})`);

      if (variant.inventory.length > 0 && isVerbose) {
        log("   Inventory by location:");
        for (const inv of variant.inventory) {
          log(
            `     - ${inv.location.name}: ${inv.quantity} qty, ${inv.reservedQty} reserved`,
          );
        }
      }
    }

    // Step 5: Build the payload that would be sent to Odoo
    logSection("Step 4: Odoo Payload Preview");

    const variantsInChannel = variantSummary.filter((v) => v.inChannel);

    if (variantsInChannel.length === 0) {
      log(
        "âš ï¸  No variants in the linked sales channel - nothing to sync",
        "yellow",
      );
      process.exit(0);
    }

    const odooPayload = {
      product: {
        name: product.name,
        default_code: variantsInChannel[0].sku,
        vendor_on_hand_qty: variantsInChannel.reduce(
          (sum, v) => sum + v.availableStock,
          0,
        ),
      },
      supplier: {
        price: variantsInChannel[0].price,
      },
      variants: variantsInChannel.map((v) => ({
        default_code: v.sku,
        vendor_on_hand_qty: v.availableStock,
        price: v.price,
        attributes: { Strength: v.strength },
      })),
    };

    log("Payload that will be sent to Odoo:", "cyan");
    console.log(JSON.stringify(odooPayload, null, 2));

    // Store config info for export
    apiCallLog.configuration = {
      baseUrl: config.baseUrl,
      salesChannelId: config.salesChannelId,
      salesChannelName: salesChannel?.name || null,
      isEnabled: config.isEnabled,
    };
    apiCallLog.productInfo = {
      id: product.id,
      name: product.name,
      variantCount: product.variants.length,
      variantsInChannel: variantsInChannel.length,
    };

    // Step 6: Execute the sync (unless dry run)
    if (isDryRun) {
      logSection("Step 5: Dry Run - What Would Be Sent");
      log(
        "ğŸ” DRY RUN - Showing full API flow that would be executed\n",
        "yellow",
      );

      const baseUrl = config.baseUrl || "<BASE_URL>";
      const apiKey = config.apiKey
        ? config.apiKey.substring(0, 8) + "..."
        : "<API_KEY>";

      // 1. CREATE PRODUCT (with all variants)
      log(`\n${"â”€".repeat(50)}`, "cyan");
      log(`ğŸ“¤ CALL 1: CREATE PRODUCT`, "bright");
      log(`${"â”€".repeat(50)}`, "cyan");

      const createEndpoint = "/vendor_api/product/create";
      const createUrl = `${baseUrl}${createEndpoint}`;

      log(`\nMethod: POST`);
      log(`URL: ${createUrl}`);
      log(`\nHeaders:`);
      log(`  Content-Type: application/json`);
      log(`  api-key: ${apiKey}`);
      log(`\nRequest Body:`);
      console.log(JSON.stringify(odooPayload, null, 2));

      logApiCall({
        operation: "CREATE_PRODUCT",
        method: "POST",
        fullUrl: createUrl,
        endpoint: createEndpoint,
        requestHeaders: {
          "Content-Type": "application/json",
          "api-key": apiKey,
        },
        requestBody: odooPayload,
        response: null,
        success: null,
        skipped: true,
        note: "Dry run - no actual API call made",
      });

      // 2. UPDATE INVENTORY for each variant
      for (let i = 0; i < variantsInChannel.length; i++) {
        const variant = variantsInChannel[i];

        log(`\n${"â”€".repeat(50)}`, "cyan");
        log(`ğŸ“¤ CALL ${i + 2}: UPDATE INVENTORY - ${variant.sku}`, "bright");
        log(`${"â”€".repeat(50)}`, "cyan");

        const updateEndpoint = "/vendor_api/product/update";
        const updateUrl = `${baseUrl}${updateEndpoint}`;

        const updatePayload = {
          default_code: variant.sku,
          product: {
            vendor_on_hand_qty: variant.availableStock,
          },
          supplier: {
            price: variant.price,
          },
          variants: [
            {
              default_code: variant.sku,
              vendor_on_hand_qty: variant.availableStock,
              price: variant.price,
              attributes: { Strength: variant.strength },
            },
          ],
        };

        log(`\nMethod: POST`);
        log(`URL: ${updateUrl}`);
        log(`\nHeaders:`);
        log(`  Content-Type: application/json`);
        log(`  api-key: ${apiKey}`);
        log(`\nRequest Body:`);
        console.log(JSON.stringify(updatePayload, null, 2));

        logApiCall({
          operation: `UPDATE_INVENTORY (${variant.sku})`,
          method: "POST",
          fullUrl: updateUrl,
          endpoint: updateEndpoint,
          requestHeaders: {
            "Content-Type": "application/json",
            "api-key": apiKey,
          },
          requestBody: updatePayload,
          response: null,
          success: null,
          skipped: true,
          note: "Dry run - no actual API call made",
        });
      }

      log(`\n${"â”€".repeat(50)}`, "cyan");
      log(
        `\nâœ… Dry run complete - ${variantsInChannel.length + 1} API calls would be made`,
        "green",
      );
      log(`   Run without --dry-run to actually sync to Odoo`, "yellow");
    } else {
      // LIVE SYNC
      logSection("Step 5: Executing Full Sync Flow");

      const odooClient = require("../integrations/skydell_odoo/odooClient");

      // Check if product exists first
      const baseVariantSku = variantsInChannel[0].sku;
      log(
        `Checking if product exists in Odoo (SKU: ${baseVariantSku})...`,
        "blue",
      );

      let productExists = false;
      try {
        productExists = await odooClient.productExists(baseVariantSku);
        log(
          `Product exists: ${productExists ? "Yes - will UPDATE" : "No - will CREATE"}`,
          productExists ? "yellow" : "green",
        );
      } catch (checkError) {
        log(`Could not check: ${checkError.message}`, "yellow");
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CALL 1: CREATE or UPDATE Product (with all variants)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      log(`\n${"â”€".repeat(50)}`, "cyan");
      log(
        `ğŸ“¤ CALL 1: ${productExists ? "UPDATE" : "CREATE"} PRODUCT`,
        "bright",
      );
      log(`${"â”€".repeat(50)}`, "cyan");

      const endpoint1 = productExists
        ? "/vendor_api/product/update"
        : "/vendor_api/product/create";
      const fullUrl1 = `${config.baseUrl}${endpoint1}`;

      const requestBody1 = productExists
        ? {
            default_code: baseVariantSku,
            product: {
              vendor_on_hand_qty: odooPayload.product.vendor_on_hand_qty,
            },
            supplier: odooPayload.supplier,
            variants: odooPayload.variants,
          }
        : odooPayload;

      log(`\nMethod: POST`);
      log(`URL: ${fullUrl1}`);
      log(`\nHeaders:`);
      log(`  Content-Type: application/json`);
      log(
        `  api-key: ${config.apiKey ? config.apiKey.substring(0, 8) + "..." : "<not set>"}`,
      );
      log(`\nRequest Body:`);
      console.log(JSON.stringify(requestBody1, null, 2));

      // Execute the call
      const startTime1 = Date.now();
      let response1;
      try {
        if (productExists) {
          response1 = await odooClient.updateProductWithVariants(
            baseVariantSku,
            { vendor_on_hand_qty: odooPayload.product.vendor_on_hand_qty },
            odooPayload.supplier,
            odooPayload.variants,
          );
        } else {
          response1 = await odooClient.createProductWithVariants(
            odooPayload.product,
            odooPayload.supplier,
            odooPayload.variants,
          );
        }
      } catch (err) {
        response1 = { success: false, error: err.message };
      }
      const duration1 = Date.now() - startTime1;

      log(`\nğŸ“¥ Response (${duration1}ms):`, "bright");
      if (response1.success) {
        log(`Status: âœ… SUCCESS`, "green");
      } else {
        log(`Status: âŒ FAILED`, "red");
      }
      console.log(
        JSON.stringify(response1.data || response1.error || response1, null, 2),
      );

      logApiCall({
        operation: productExists ? "UPDATE_PRODUCT" : "CREATE_PRODUCT",
        method: "POST",
        fullUrl: fullUrl1,
        endpoint: endpoint1,
        requestHeaders: {
          "Content-Type": "application/json",
          "api-key": config.apiKey
            ? `${config.apiKey.substring(0, 8)}...`
            : null,
        },
        requestBody: requestBody1,
        response: response1.data || response1.error || response1,
        statusCode: response1.status || null,
        duration: duration1,
        success: response1.success,
        skipped: false,
        error: response1.success ? null : response1.error || "Unknown error",
      });

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CALLS 2+: UPDATE INVENTORY for each variant individually
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      for (let i = 0; i < variantsInChannel.length; i++) {
        const variant = variantsInChannel[i];

        log(`\n${"â”€".repeat(50)}`, "cyan");
        log(`ğŸ“¤ CALL ${i + 2}: UPDATE INVENTORY - ${variant.sku}`, "bright");
        log(`${"â”€".repeat(50)}`, "cyan");

        const updateEndpoint = "/vendor_api/product/update";
        const updateUrl = `${config.baseUrl}${updateEndpoint}`;

        const updatePayload = {
          default_code: variant.sku,
          product: {
            vendor_on_hand_qty: variant.availableStock,
          },
          supplier: {
            price: variant.price,
          },
          variants: [
            {
              default_code: variant.sku,
              vendor_on_hand_qty: variant.availableStock,
              price: variant.price,
              attributes: { Strength: variant.strength },
            },
          ],
        };

        log(`\nMethod: POST`);
        log(`URL: ${updateUrl}`);
        log(`\nHeaders:`);
        log(`  Content-Type: application/json`);
        log(
          `  api-key: ${config.apiKey ? config.apiKey.substring(0, 8) + "..." : "<not set>"}`,
        );
        log(`\nRequest Body:`);
        console.log(JSON.stringify(updatePayload, null, 2));

        // Execute the update call
        const startTimeN = Date.now();
        let responseN;
        try {
          responseN = await odooClient.updateProductWithVariants(
            variant.sku,
            { vendor_on_hand_qty: variant.availableStock },
            { price: variant.price },
            [
              {
                default_code: variant.sku,
                vendor_on_hand_qty: variant.availableStock,
                price: variant.price,
                attributes: { Strength: variant.strength },
              },
            ],
          );
        } catch (err) {
          responseN = { success: false, error: err.message };
        }
        const durationN = Date.now() - startTimeN;

        log(`\nğŸ“¥ Response (${durationN}ms):`, "bright");
        if (responseN.success) {
          log(`Status: âœ… SUCCESS`, "green");
        } else {
          log(`Status: âŒ FAILED`, "red");
        }
        console.log(
          JSON.stringify(
            responseN.data || responseN.error || responseN,
            null,
            2,
          ),
        );

        logApiCall({
          operation: `UPDATE_INVENTORY (${variant.sku})`,
          method: "POST",
          fullUrl: updateUrl,
          endpoint: updateEndpoint,
          requestHeaders: {
            "Content-Type": "application/json",
            "api-key": config.apiKey
              ? `${config.apiKey.substring(0, 8)}...`
              : null,
          },
          requestBody: updatePayload,
          response: responseN.data || responseN.error || responseN,
          statusCode: responseN.status || null,
          duration: durationN,
          success: responseN.success,
          skipped: false,
          error: responseN.success ? null : responseN.error || "Unknown error",
        });

        // Small delay between calls to not overwhelm the API
        if (i < variantsInChannel.length - 1) {
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      }

      log(`\n${"â”€".repeat(50)}`, "cyan");
      const successCount = apiCallLog.calls.filter(
        (c) => c.success === true,
      ).length;
      const failCount = apiCallLog.calls.filter(
        (c) => c.success === false,
      ).length;
      log(
        `\nğŸ“Š Results: ${successCount} succeeded, ${failCount} failed out of ${apiCallLog.calls.length} calls`,
        failCount > 0 ? "yellow" : "green",
      );
    }

    // Summary
    logSection("Summary");
    log(`Product: ${product.name}`, "bright");
    log(
      `Variants: ${product.variants.length} total, ${variantsInChannel.length} in channel`,
    );
    log(
      `Total Available Stock: ${variantsInChannel.reduce((sum, v) => sum + v.availableStock, 0)}`,
    );
    log(`Mode: ${isDryRun ? "Dry Run" : "Live Sync"}`);

    // Export API log if requested
    if (shouldExport) {
      const exportPath = exportApiLog(
        config,
        product,
        variantsInChannel,
        odooPayload,
      );
      logSection("Export Complete");
      log(`ğŸ“„ API report exported to: ${exportPath}`, "green");
      log(
        `   Share this markdown file with the Odoo implementation team for review.`,
        "cyan",
      );
    }

    log("\nâœ… Test complete!", "green");

    if (!shouldExport && !isDryRun) {
      log(
        `\nğŸ’¡ Tip: Run with --export flag to save API logs to a file for sharing`,
        "cyan",
      );
    }
  } catch (error) {
    log(`\nâŒ Error: ${error.message}`, "red");
    if (isVerbose) {
      console.error(error);
    }
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Run the script
main();
